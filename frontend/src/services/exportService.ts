import type { LectureSession, ExportOptions, TranscriptSegment } from '../types';
import { formatDuration } from '../utils/audioProcessor';

export class ExportService {
  async exportSession(
    session: LectureSession,
    options: ExportOptions
  ): Promise<{ data: string | Blob; filename: string; mimeType: string }> {
    const { format, includeTimestamps, includeSummary, includeMetadata, language } = options;

    const filteredSegments = this.filterSegmentsByLanguage(session.segments, language);
    const content = this.generateContent(session, filteredSegments, {
      includeTimestamps,
      includeSummary,
      includeMetadata,
    });

    switch (format) {
      case 'txt':
        return this.exportAsText(content, session.name);
      case 'md':
        return this.exportAsMarkdown(content, session.name);
      case 'docx':
        return this.exportAsDocx(content, session.name);
      case 'notion':
        return this.exportForNotion(content, session.name);
      case 'gdocs':
        return this.exportForGoogleDocs(content, session.name);
      default:
        throw new Error(`Unsupported export format: ${format}`);
    }
  }

  private filterSegmentsByLanguage(
    segments: TranscriptSegment[],
    language: 'zh' | 'en' | 'both'
  ): TranscriptSegment[] {
    if (language === 'both') {
      return segments;
    }

    return segments.filter(segment => {
      const isChineseText = /[\u4e00-\u9fff]/.test(segment.text);
      const isEnglishText = /[a-zA-Z]/.test(segment.text);

      if (language === 'zh') {
        return isChineseText;
      } else if (language === 'en') {
        return isEnglishText && !isChineseText;
      }

      return true;
    });
  }

  private generateContent(
    session: LectureSession,
    segments: TranscriptSegment[],
    options: {
      includeTimestamps: boolean;
      includeSummary: boolean;
      includeMetadata: boolean;
    }
  ): {
    title: string;
    metadata: string;
    transcript: string;
    summary: string;
  } {
    const { includeTimestamps, includeSummary, includeMetadata } = options;

    const title = session.name;

    // Generate metadata
    let metadata = '';
    if (includeMetadata) {
      const startDate = new Date(session.startTime).toLocaleString();
      const duration = formatDuration(session.duration);
      const wordCount = session.segments.reduce((acc, seg) => acc + seg.text.split(' ').length, 0);

      metadata = `
Date: ${startDate}
Duration: ${duration}
Word Count: ${wordCount}
Language: ${session.language === 'mixed' ? 'Cantonese/English' : session.language}
Cost: $${session.cost.toFixed(4)}
`;
    }

    // Generate transcript
    let transcript = '';
    segments.forEach((segment) => {
      const timestamp = includeTimestamps
        ? `[${this.formatTimestamp(segment.timestamp)}] `
        : '';

      transcript += `${timestamp}${segment.text.trim()}\n\n`;
    });

    // Add summary
    const summary = includeSummary && session.summary ? session.summary : '';

    return { title, metadata, transcript, summary };
  }

  private formatTimestamp(seconds: number): string {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
  }

  private exportAsText(
    content: { title: string; metadata: string; transcript: string; summary: string },
    sessionName: string
  ): { data: string; filename: string; mimeType: string } {
    let text = `${content.title}\n${'='.repeat(content.title.length)}\n\n`;

    if (content.metadata) {
      text += `METADATA\n--------\n${content.metadata}\n\n`;
    }

    if (content.transcript) {
      text += `TRANSCRIPT\n----------\n${content.transcript}\n`;
    }

    if (content.summary) {
      text += `SUMMARY\n-------\n${content.summary}\n`;
    }

    return {
      data: text,
      filename: `${this.sanitizeFilename(sessionName)}.txt`,
      mimeType: 'text/plain;charset=utf-8',
    };
  }

  private exportAsMarkdown(
    content: { title: string; metadata: string; transcript: string; summary: string },
    sessionName: string
  ): { data: string; filename: string; mimeType: string } {
    let markdown = `# ${content.title}\n\n`;

    if (content.metadata) {
      markdown += `## Metadata\n\n\`\`\`\n${content.metadata}\n\`\`\`\n\n`;
    }

    if (content.transcript) {
      markdown += `## Transcript\n\n${content.transcript}\n`;
    }

    if (content.summary) {
      markdown += `## Summary\n\n${content.summary}\n`;
    }

    markdown += `\n---\n*Generated by Lecture Transcription PWA*\n`;

    return {
      data: markdown,
      filename: `${this.sanitizeFilename(sessionName)}.md`,
      mimeType: 'text/markdown;charset=utf-8',
    };
  }

  private exportAsDocx(
    content: { title: string; metadata: string; transcript: string; summary: string },
    sessionName: string
  ): { data: string; filename: string; mimeType: string } {
    // For now, return as rich text format (RTF) which can be opened by Word
    let rtf = '{\\rtf1\\ansi\\deff0 {\\fonttbl {\\f0 Times New Roman;}}';

    rtf += `\\f0\\fs24 {\\b ${content.title}}\\par\\par`;

    if (content.metadata) {
      rtf += `{\\b Metadata}\\par${content.metadata.replace(/\n/g, '\\par')}\\par\\par`;
    }

    if (content.transcript) {
      rtf += `{\\b Transcript}\\par${content.transcript.replace(/\n/g, '\\par')}\\par`;
    }

    if (content.summary) {
      rtf += `{\\b Summary}\\par${content.summary.replace(/\n/g, '\\par')}\\par`;
    }

    rtf += '}';

    return {
      data: rtf,
      filename: `${this.sanitizeFilename(sessionName)}.rtf`,
      mimeType: 'application/rtf',
    };
  }

  private exportForNotion(
    content: { title: string; metadata: string; transcript: string; summary: string },
    sessionName: string
  ): { data: string; filename: string; mimeType: string } {
    // Notion-compatible markdown format
    let notionMarkdown = `# ${content.title}\n\n`;

    if (content.metadata) {
      notionMarkdown += `> **Lecture Information**\n`;
      content.metadata.split('\n').forEach(line => {
        if (line.trim()) {
          notionMarkdown += `> ${line}\n`;
        }
      });
      notionMarkdown += `\n`;
    }

    if (content.summary) {
      notionMarkdown += `## üìù Summary\n\n${content.summary}\n\n`;
    }

    if (content.transcript) {
      notionMarkdown += `## üì¢ Full Transcript\n\n`;
      notionMarkdown += `<details>\n<summary>Click to expand full transcript</summary>\n\n`;
      notionMarkdown += `${content.transcript}\n`;
      notionMarkdown += `</details>\n\n`;
    }

    notionMarkdown += `---\n*üì± Generated by Lecture Transcription PWA*\n`;

    return {
      data: notionMarkdown,
      filename: `${this.sanitizeFilename(sessionName)}_notion.md`,
      mimeType: 'text/markdown;charset=utf-8',
    };
  }

  private exportForGoogleDocs(
    content: { title: string; metadata: string; transcript: string; summary: string },
    sessionName: string
  ): { data: string; filename: string; mimeType: string } {
    // HTML format for Google Docs import
    let html = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>${content.title}</title>
    <style>
        body { font-family: 'Times New Roman', serif; line-height: 1.6; margin: 40px; }
        h1 { color: #1a73e8; border-bottom: 2px solid #1a73e8; }
        h2 { color: #333; margin-top: 30px; }
        .metadata { background-color: #f8f9fa; padding: 15px; border-left: 4px solid #1a73e8; }
        .timestamp { color: #666; font-weight: bold; }
        .transcript { margin: 20px 0; }
        .summary { background-color: #e8f0fe; padding: 20px; border-radius: 8px; }
    </style>
</head>
<body>`;

    html += `<h1>${content.title}</h1>`;

    if (content.metadata) {
      html += `<h2>Lecture Information</h2>
      <div class="metadata">
        ${content.metadata.replace(/\n/g, '<br>')}
      </div>`;
    }

    if (content.summary) {
      html += `<h2>Summary</h2>
      <div class="summary">
        ${content.summary.replace(/\n/g, '<br>')}
      </div>`;
    }

    if (content.transcript) {
      html += `<h2>Transcript</h2>
      <div class="transcript">`;

      const lines = content.transcript.split('\n\n');
      lines.forEach(line => {
        if (line.trim()) {
          // Check if line starts with timestamp
          const timestampMatch = line.match(/^\[(\d+:\d+)\]\s*(.+)$/);
          if (timestampMatch) {
            html += `<p><span class="timestamp">[${timestampMatch[1]}]</span> ${timestampMatch[2]}</p>`;
          } else {
            html += `<p>${line}</p>`;
          }
        }
      });

      html += `</div>`;
    }

    html += `<hr><p><em>Generated by Lecture Transcription PWA</em></p></body></html>`;

    return {
      data: html,
      filename: `${this.sanitizeFilename(sessionName)}.html`,
      mimeType: 'text/html;charset=utf-8',
    };
  }

  private sanitizeFilename(filename: string): string {
    return filename
      .replace(/[^a-z0-9\u4e00-\u9fff]/gi, '_')
      .replace(/_+/g, '_')
      .replace(/^_|_$/g, '')
      .substring(0, 100);
  }

  // Utility method to download file
  downloadFile(data: string | Blob, filename: string, mimeType: string): void {
    const blob = typeof data === 'string' ? new Blob([data], { type: mimeType }) : data;
    const url = URL.createObjectURL(blob);

    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    URL.revokeObjectURL(url);
  }

  // Share via Web Share API (if available)
  async shareFile(
    session: LectureSession,
    options: ExportOptions
  ): Promise<boolean> {
    if (!navigator.share) {
      return false;
    }

    try {
      const { data, filename } = await this.exportSession(session, options);
      const blob = typeof data === 'string' ? new Blob([data], { type: 'text/plain' }) : data;
      const file = new File([blob], filename, { type: blob.type });

      await navigator.share({
        title: session.name,
        text: `Lecture transcript: ${session.name}`,
        files: [file],
      });

      return true;
    } catch (error) {
      console.error('Web Share failed:', error);
      return false;
    }
  }

  // Generate shareable summary for social media
  generateShareableText(session: LectureSession): string {
    const duration = formatDuration(session.duration);
    const wordCount = session.segments.reduce((acc, seg) => acc + seg.text.split(' ').length, 0);

    return `üìö Just transcribed: "${session.name}"
‚è±Ô∏è Duration: ${duration}
üìù Words: ${wordCount.toLocaleString()}
üí∞ Cost: $${session.cost.toFixed(4)}

#LectureNotes #Study #UniversityLife #HongKong`;
  }
}